package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"bytes"
	"context"
	"database/sql"
	"encoding/base64"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/service/s3"
	"github.com/jung-kurt/gofpdf"
	"github.com/levanter914/login-page/backend/graph/model"
	"github.com/levanter914/login-page/backend/graph/utils"
	"golang.org/x/crypto/bcrypt"
)

// Signup is the resolver for the signup field.
func (r *mutationResolver) Signup(ctx context.Context, input model.SignupInput) (*model.AuthPayload, error) {
	if len(input.Password) < 6 {
		return nil, errors.New("password must be at least 6 characters")
	}

	// Check if email exists
	var exists bool
	err := DB.QueryRow("SELECT EXISTS(SELECT 1 FROM auth WHERE email=$1)", input.Email).Scan(&exists)
	if err != nil {
		return nil, err
	}
	if exists {
		return nil, errors.New("email already in use")
	}

	// Hash password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		return nil, err
	}

	var userID int64
	err = DB.QueryRow(
		"INSERT INTO auth (email, password) VALUES ($1, $2) RETURNING id",
		input.Email, hashedPassword,
	).Scan(&userID)
	if err != nil {
		return nil, err
	}

	_, err = DB.Exec(`
		INSERT INTO user_profile (id, first_name, last_name, phone_number, company, profilepicurl)
		VALUES ($1, $2, $3, $4, $5, $6)
	`, userID, input.FirstName, input.LastName, input.PhoneNumber, input.Company, input.ProfilePicURL)
	if err != nil {
		return nil, err
	}

	token, err := utils.GenerateJWT(fmt.Sprintf("%d", userID))
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		Token: token,
		User: &model.User{
			ID:            fmt.Sprintf("%d", userID),
			Email:         input.Email,
			FirstName:     &input.FirstName,
			LastName:      &input.LastName,
			PhoneNumber:   input.PhoneNumber,
			Company:       input.Company,
			ProfilePicURL: input.ProfilePicURL, // Update to ProfilePicURL
		},
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	// Query the database for user credentials based on email
	row := DB.QueryRow(`
        SELECT a.id, a.password, up.first_name, up.last_name, up.phone_number, up.company, up.profilepicurl
        FROM auth a
        JOIN user_profile up ON a.id = up.id
        WHERE a.email = $1
    `, input.Email)

	var id int64
	var hashedPassword string
	var firstName, lastName, phoneNumber, company, profilePicURL sql.NullString

	err := row.Scan(&id, &hashedPassword, &firstName, &lastName, &phoneNumber, &company, &profilePicURL)
	if err != nil {
		return nil, errors.New("invalid credentials")
	}

	err = bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(input.Password))
	if err != nil {
		return nil, errors.New("invalid password")
	}

	token, err := utils.GenerateJWT(fmt.Sprintf("%d", id))
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		Token: token,
		User: &model.User{
			ID:            fmt.Sprintf("%d", id),
			Email:         input.Email,
			FirstName:     nullStringToPtr(firstName),
			LastName:      nullStringToPtr(lastName),
			PhoneNumber:   nullStringToPtr(phoneNumber),
			Company:       nullStringToPtr(company),
			ProfilePicURL: nullStringToPtr(profilePicURL),
		},
	}, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	userID, ok := GetUserIDFromContext(ctx)
	if !ok {
		return nil, errors.New("unauthenticated")
	}

	row := DB.QueryRow(`
		SELECT a.email, up.first_name, up.last_name, up.phone_number, up.company, up.profilepicurl
		FROM auth a
		JOIN user_profile up ON a.id = up.id
		WHERE a.id = $1
	`, userID)

	var email string
	var firstName, lastName, phoneNumber, company, profileImageURL sql.NullString

	err := row.Scan(&email, &firstName, &lastName, &phoneNumber, &company, &profileImageURL)
	if err != nil {
		return nil, errors.New("user not found")
	}

	return &model.User{
		ID:            userID,
		Email:         email,
		FirstName:     nullStringToPtr(firstName),
		LastName:      nullStringToPtr(lastName),
		PhoneNumber:   nullStringToPtr(phoneNumber),
		Company:       nullStringToPtr(company),
		ProfilePicURL: nullStringToPtr(profileImageURL), // Updated to ProfilePicURL
	}, nil
}

// GetPresignedURL is the resolver for the getPresignedUrl field.
func (r *queryResolver) GetPresignedURL(ctx context.Context, fileName string) (string, error) {
	cfg, err := config.LoadDefaultConfig(context.TODO(), config.WithRegion("eu-north-1"))
	if err != nil {
		return "", fmt.Errorf("unable to load AWS configuration: %v", err)
	}

	s3Client := s3.NewFromConfig(cfg)
	presignClient := s3.NewPresignClient(s3Client)

	req, err := presignClient.PresignPutObject(context.TODO(), &s3.PutObjectInput{
		Bucket:      aws.String("levanter914-s3-user-profile-pictures"),
		Key:         aws.String(fileName),
		ContentType: aws.String("image/jpeg"),
		//ACL:         types.ObjectCannedACLPublicRead,
	}, s3.WithPresignExpires(1*time.Hour))

	if err != nil {
		return "", fmt.Errorf("unable to sign request: %v", err)
	}

	if req.URL == "" {
		return "", fmt.Errorf("failed to generate presigned URL")
	}

	return req.URL, nil
}

// GetBillPDF is the resolver for the getBillPDF field.
func (r *queryResolver) GetBillPDF(ctx context.Context, billID int32, typeArg string) (string, error) {
	userID, ok := GetUserIDFromContext(ctx)
	if !ok {
		return "", errors.New("unauthenticated")
	}

	rows, err := DB.Query(`
		SELECT bill_id, bill_type, customer_name, company, phone_number, created_at,
		       item_description, quantity, unit_price, total_price,
		       subtotal, tax, discount, total, notes, payment_amount, payment_method, paid_at
		FROM full_receipt_view
		WHERE bill_id = $1 AND user_id = $2
	`, billID, userID)
	if err != nil {
		return "", fmt.Errorf("query failed: %v", err)
	}
	defer rows.Close()

	var (
		items []struct {
			Description string
			Quantity    int
			UnitPrice   float64
			TotalPrice  float64
		}
		firstRowFetched = false

		// Shared fields (only fetched once)
		resolvedBillType, customerName, company, phone, notes, paymentMethod string
		createdAt, paidAt                                                    time.Time
		subtotal, tax, discount, total, paymentAmount                        float64
	)

	for rows.Next() {
		var (
			itemDesc                                                               string
			quantity                                                               int
			unitPrice, totalPrice                                                  float64
			tmpBillID                                                              int
			tmpCreatedAt, tmpPaidAt                                                time.Time
			tmpSubtotal, tmpTax, tmpDiscount, tmpTotal, tmpPaymentAmount           float64
			tmpBillType, tmpCustomer, tmpCompany, tmpPhone, tmpNotes, tmpPayMethod string
		)

		err := rows.Scan(
			&tmpBillID, &tmpBillType, &tmpCustomer, &tmpCompany, &tmpPhone, &tmpCreatedAt,
			&itemDesc, &quantity, &unitPrice, &totalPrice,
			&tmpSubtotal, &tmpTax, &tmpDiscount, &tmpTotal, &tmpNotes,
			&tmpPaymentAmount, &tmpPayMethod, &tmpPaidAt,
		)
		if err != nil {
			return "", fmt.Errorf("scan failed: %v", err)
		}

		items = append(items, struct {
			Description string
			Quantity    int
			UnitPrice   float64
			TotalPrice  float64
		}{itemDesc, quantity, unitPrice, totalPrice})

		if !firstRowFetched {
			resolvedBillType = tmpBillType
			customerName = tmpCustomer
			company = tmpCompany
			phone = tmpPhone
			createdAt = tmpCreatedAt
			paidAt = tmpPaidAt
			subtotal = tmpSubtotal
			tax = tmpTax
			discount = tmpDiscount
			total = tmpTotal
			notes = tmpNotes
			paymentAmount = tmpPaymentAmount
			paymentMethod = tmpPayMethod
			firstRowFetched = true
		}
	}

	// Generate 80mm width PDF with variable height
	pdf := gofpdf.NewCustom(&gofpdf.InitType{
		UnitStr: "mm",
		Size: gofpdf.SizeType{
			Wd: 80,
			Ht: 300, // arbitrary start, grows dynamically
		},
	})
	pdf.AddPage()
	pdf.SetFont("Arial", "B", 14)
	pdf.Cell(0, 10, fmt.Sprintf("%s BILL", strings.ToUpper(resolvedBillType)))
	pdf.Ln(8)

	// Customer details
	pdf.SetFont("Arial", "", 10)
	pdf.Cell(0, 5, fmt.Sprintf("Customer: %s", customerName))
	pdf.Ln(5)
	pdf.Cell(0, 5, fmt.Sprintf("Phone: %s", phone))
	pdf.Ln(5)
	pdf.Cell(0, 5, fmt.Sprintf("Company: %s", company)) // Company name
	pdf.Ln(5)
	pdf.Cell(0, 5, fmt.Sprintf("Date: %s", createdAt.Format("02 Jan 2006 15:04")))
	pdf.Ln(8)

	// Table header
	pdf.SetFont("Arial", "B", 10)
	pdf.CellFormat(40, 6, "Item", "B", 0, "L", false, 0, "")
	pdf.CellFormat(10, 6, "Qty", "B", 0, "C", false, 0, "")
	pdf.CellFormat(15, 6, "Price", "B", 0, "R", false, 0, "")
	pdf.CellFormat(15, 6, "Total", "B", 1, "R", false, 0, "")

	// Itemized details (items purchased)
	pdf.SetFont("Arial", "", 10)
	for _, item := range items {
		pdf.CellFormat(40, 5, item.Description, "", 0, "L", false, 0, "")
		pdf.CellFormat(10, 5, fmt.Sprintf("%d", item.Quantity), "", 0, "C", false, 0, "")
		pdf.CellFormat(15, 5, fmt.Sprintf("%.2f", item.UnitPrice), "", 0, "R", false, 0, "")
		pdf.CellFormat(15, 5, fmt.Sprintf("%.2f", item.TotalPrice), "", 1, "R", false, 0, "")
	}

	// Summary Section
	pdf.Ln(5)
	pdf.CellFormat(60, 5, "Subtotal", "", 0, "R", false, 0, "")
	pdf.CellFormat(20, 5, fmt.Sprintf("%.2f", subtotal), "", 1, "R", false, 0, "")
	pdf.CellFormat(60, 5, "Tax", "", 0, "R", false, 0, "")
	pdf.CellFormat(20, 5, fmt.Sprintf("%.2f", tax), "", 1, "R", false, 0, "")
	pdf.CellFormat(60, 5, "Discount", "", 0, "R", false, 0, "")
	pdf.CellFormat(20, 5, fmt.Sprintf("-%.2f", discount), "", 1, "R", false, 0, "")
	pdf.CellFormat(60, 5, "Total", "", 0, "R", false, 0, "")
	pdf.CellFormat(20, 5, fmt.Sprintf("%.2f", total), "", 1, "R", false, 0, "")

	// Add Payment Amount
	pdf.Ln(5)
	pdf.CellFormat(60, 5, "Payment Amount", "", 0, "R", false, 0, "")
	pdf.CellFormat(20, 5, fmt.Sprintf("%.2f", paymentAmount), "", 1, "R", false, 0, "")

	// Notes and Footer
	pdf.Ln(5)
	pdf.MultiCell(0, 5, notes, "", "C", false)
	pdf.Ln(5)
	pdf.CellFormat(0, 5, fmt.Sprintf("Paid via %s on %s", paymentMethod, paidAt.Format("02 Jan 2006 15:04")), "", 1, "C", false, 0, "")

	// Output PDF
	var buf bytes.Buffer
	if err := pdf.Output(&buf); err != nil {
		return "", fmt.Errorf("PDF generation failed: %v", err)
	}

	return base64.StdEncoding.EncodeToString(buf.Bytes()), nil
}

// GetBills is the resolver for the getBills field.
func (r *queryResolver) GetBills(ctx context.Context, page int32, size int32) (*model.BillPaginationResult, error) {
	offset := (page - 1) * size

	rows, err := DB.Query(`
        SELECT bill_id, company, created_at, payment_amount
        FROM full_receipt_view
        ORDER BY created_at DESC
        LIMIT $1 OFFSET $2
    `, size, offset)
	if err != nil {
		return nil, fmt.Errorf("query error: %v", err)
	}
	defer rows.Close()

	var bills []*model.Bill
	for rows.Next() {
		var b model.Bill
		if err := rows.Scan(&b.BillID, &b.Company, &b.CreatedAt, &b.TotalAmount); err != nil {
			return nil, err
		}
		bills = append(bills, &b)
	}

	var totalCount int32
	err = DB.QueryRow(`SELECT COUNT(*) FROM full_receipt_view`).Scan(&totalCount)
	if err != nil {
		return nil, fmt.Errorf("count error: %v", err)
	}

	return &model.BillPaginationResult{
		TotalCount: totalCount,
		Bills:      bills,
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
