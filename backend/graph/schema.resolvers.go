package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/service/s3"
	"github.com/jung-kurt/gofpdf"
	"github.com/levanter914/login-page/backend/graph/model"
	"github.com/levanter914/login-page/backend/graph/utils"
	"golang.org/x/crypto/bcrypt"
)

// Signup is the resolver for the signup field.
func (r *mutationResolver) Signup(ctx context.Context, input model.SignupInput) (*model.AuthPayload, error) {
	if len(input.Password) < 6 {
		return nil, errors.New("password must be at least 6 characters")
	}

	// Check if email exists
	var exists bool
	err := DB.QueryRow("SELECT EXISTS(SELECT 1 FROM auth WHERE email=$1)", input.Email).Scan(&exists)
	if err != nil {
		return nil, err
	}
	if exists {
		return nil, errors.New("email already in use")
	}

	// Hash password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		return nil, err
	}

	var userID int64
	err = DB.QueryRow(
		"INSERT INTO auth (email, password) VALUES ($1, $2) RETURNING id",
		input.Email, hashedPassword,
	).Scan(&userID)
	if err != nil {
		return nil, err
	}

	_, err = DB.Exec(`
		INSERT INTO user_profile (id, first_name, last_name, phone_number, company, profilepicurl)
		VALUES ($1, $2, $3, $4, $5, $6)
	`, userID, input.FirstName, input.LastName, input.PhoneNumber, input.Company, input.ProfilePicURL)
	if err != nil {
		return nil, err
	}

	token, err := utils.GenerateJWT(fmt.Sprintf("%d", userID))
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		Token: token,
		User: &model.User{
			ID:            fmt.Sprintf("%d", userID),
			Email:         input.Email,
			FirstName:     &input.FirstName,
			LastName:      &input.LastName,
			PhoneNumber:   input.PhoneNumber,
			Company:       input.Company,
			ProfilePicURL: input.ProfilePicURL, // Update to ProfilePicURL
		},
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	// Query the database for user credentials based on email
	row := DB.QueryRow(`
        SELECT a.id, a.password, up.first_name, up.last_name, up.phone_number, up.company, up.profilepicurl
        FROM auth a
        JOIN user_profile up ON a.id = up.id
        WHERE a.email = $1
    `, input.Email)

	var id int64
	var hashedPassword string
	var firstName, lastName, phoneNumber, company, profilePicURL sql.NullString

	err := row.Scan(&id, &hashedPassword, &firstName, &lastName, &phoneNumber, &company, &profilePicURL)
	if err != nil {
		return nil, errors.New("invalid credentials")
	}

	err = bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(input.Password))
	if err != nil {
		return nil, errors.New("invalid password")
	}

	token, err := utils.GenerateJWT(fmt.Sprintf("%d", id))
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		Token: token,
		User: &model.User{
			ID:            fmt.Sprintf("%d", id),
			Email:         input.Email,
			FirstName:     nullStringToPtr(firstName),
			LastName:      nullStringToPtr(lastName),
			PhoneNumber:   nullStringToPtr(phoneNumber),
			Company:       nullStringToPtr(company),
			ProfilePicURL: nullStringToPtr(profilePicURL),
		},
	}, nil
}

// GetBillPDF is the resolver for the getBillPDF field.
func (r *mutationResolver) GetBillPDF(ctx context.Context, billID int32) (string, error) {
	// Step 1: Fetch the bill data from the database
	var company string
	var total float64
	var createdAt time.Time

	err := DB.QueryRow(`
        SELECT company, total, created_at
        FROM bill_summary_view
        WHERE bill_id = $1
    `, billID).Scan(&company, &total, &createdAt)

	if err != nil {
		return "", fmt.Errorf("bill not found: %v", err)
	}

	// Step 2: Generate the PDF with gofpdf
	pdf := gofpdf.New("P", "mm", "A4", "")
	pdf.AddPage()

	// Set the title of the PDF (Bold, size 16)
	pdf.SetFont("Arial", "B", 16)
	pdf.Cell(40, 10, fmt.Sprintf("Bill #%d", billID))
	pdf.Ln(12)

	// Set the content of the PDF (Regular, size 12)
	pdf.SetFont("Arial", "", 12)
	pdf.Cell(40, 10, fmt.Sprintf("Company: %s", company))
	pdf.Ln(8)
	pdf.Cell(40, 10, fmt.Sprintf("Total: â‚¹%.2f", total))
	pdf.Ln(8)
	pdf.Cell(40, 10, fmt.Sprintf("Date: %s", createdAt.Format("2006-01-02 15:04")))

	// Step 3: Save the PDF to the file system
	fileName := fmt.Sprintf("bill_%d_%s.pdf", billID, time.Now().Format("20060102150405"))
	filePath := fmt.Sprintf("./static/pdfs/%s", fileName)

	// Generate and save the PDF to the file
	err = pdf.OutputFileAndClose(filePath)
	if err != nil {
		return "", fmt.Errorf("failed to save PDF: %v", err)
	}

	// Step 4: Return the public URL of the generated PDF
	return fmt.Sprintf("http://localhost:8080/static/pdfs/%s", fileName), nil
}


// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	userID, ok := GetUserIDFromContext(ctx)
	if !ok {
		return nil, errors.New("unauthenticated")
	}

	row := DB.QueryRow(`
		SELECT a.email, up.first_name, up.last_name, up.phone_number, up.company, up.profilepicurl
		FROM auth a
		JOIN user_profile up ON a.id = up.id
		WHERE a.id = $1
	`, userID)

	var email string
	var firstName, lastName, phoneNumber, company, profileImageURL sql.NullString

	err := row.Scan(&email, &firstName, &lastName, &phoneNumber, &company, &profileImageURL)
	if err != nil {
		return nil, errors.New("user not found")
	}

	return &model.User{
		ID:            userID,
		Email:         email,
		FirstName:     nullStringToPtr(firstName),
		LastName:      nullStringToPtr(lastName),
		PhoneNumber:   nullStringToPtr(phoneNumber),
		Company:       nullStringToPtr(company),
		ProfilePicURL: nullStringToPtr(profileImageURL), // Updated to ProfilePicURL
	}, nil
}

// GetPresignedURL is the resolver for the getPresignedUrl field.
func (r *queryResolver) GetPresignedURL(ctx context.Context, fileName string) (string, error) {
	cfg, err := config.LoadDefaultConfig(context.TODO(), config.WithRegion("eu-north-1"))
	if err != nil {
		return "", fmt.Errorf("unable to load AWS configuration: %v", err)
	}

	s3Client := s3.NewFromConfig(cfg)
	presignClient := s3.NewPresignClient(s3Client)

	req, err := presignClient.PresignPutObject(context.TODO(), &s3.PutObjectInput{
		Bucket:      aws.String("levanter914-s3-user-profile-pictures"),
		Key:         aws.String(fileName),
		ContentType: aws.String("image/jpeg"),
		//ACL:         types.ObjectCannedACLPublicRead,
	}, s3.WithPresignExpires(1*time.Hour))

	if err != nil {
		return "", fmt.Errorf("unable to sign request: %v", err)
	}

	if req.URL == "" {
		return "", fmt.Errorf("failed to generate presigned URL")
	}

	return req.URL, nil
}

// GetBills is the resolver for the getBills field.
func (r *queryResolver) GetBills(ctx context.Context, page int32, size int32) (*model.BillPaginationResult, error) {
	offset := (page - 1) * size

	rows, err := DB.Query(`
        SELECT bill_id, company, created_at, total
        FROM bill_summary_view
        ORDER BY created_at DESC
        LIMIT $1 OFFSET $2
    `, size, offset)
	if err != nil {
		return nil, fmt.Errorf("query error: %v", err)
	}
	defer rows.Close()

	var bills []*model.Bill
	for rows.Next() {
		var b model.Bill
		if err := rows.Scan(&b.BillID, &b.Company, &b.CreatedAt, &b.TotalAmount); err != nil {
			return nil, err
		}
		bills = append(bills, &b)
	}

	var totalCount int32
	err = DB.QueryRow(`SELECT COUNT(*) FROM bill_summary_view`).Scan(&totalCount)
	if err != nil {
		return nil, fmt.Errorf("count error: %v", err)
	}

	return &model.BillPaginationResult{
		TotalCount: totalCount,
		Bills:      bills,
	}, nil
}

func (r *queryResolver) GetBillDetails(ctx context.Context, billID int) (*model.BillDetails, error) {
	// Get bill
	bill, err := r.BillRepo.GetByID(ctx, billID)
	if err != nil {
		return nil, err
	}

	// Get user profile
	userProfile, err := r.UserRepo.GetProfileByUserID(ctx, int64(bill.BillID))
	if err != nil {
		return nil, err
	}

	// Get items
	items, err := r.BillItem.GetItemsByBillID(ctx, billID)
	if err != nil {
		return nil, err
	}

	// Get payment
	payment, err := r.PaymentRepo.GetByBillID(ctx, billID)
	if err != nil && err != sql.ErrNoRows {
		return nil, err
	}

	// Format result
	billDetails := &model.BillDetails{
		BillID:    int(bill.BillID),
		CreatedAt: bill.CreatedAt,
		BillType:  bill.BillType,
		Notes:     bill.Notes,
		Subtotal:  bill.Subtotal,
		Tax:       bill.Tax,
		Discount:  bill.Discount,
		Total:     bill.Total,
		User: &model.UserProfile{
			FirstName:   userProfile.FirstName,
			LastName:    userProfile.LastName,
			PhoneNumber: userProfile.PhoneNumber,
			Company:     userProfile.Company,
		},
		Items:   items,
		Payment: payment,
	}

	return billDetails, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

