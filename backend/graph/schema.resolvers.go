package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"context"
	"database/sql"
	"errors"
	"fmt"

	"github.com/levanter914/login-page/backend/graph/model"
	"github.com/levanter914/login-page/backend/graph/utils"
	"golang.org/x/crypto/bcrypt"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.AuthPayload, error) {
	row := DB.QueryRow(`
		SELECT a.id, a.password, up.first_name, up.last_name, up.phone_number, up.country, up.job
		FROM auth a
		JOIN user_profile up ON a.id = up.id
		WHERE a.email = $1
	`, email)

	var id int64
	var hashedPassword string
	var firstName, lastName, phoneNumber, country, job sql.NullString

	err := row.Scan(&id, &hashedPassword, &firstName, &lastName, &phoneNumber, &country, &job)
	if err != nil {
		return nil, errors.New("invalid credentials")
	}

	err = bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
	if err != nil {
		return nil, errors.New("invalid password")
	}

	token, err := utils.GenerateJWT(fmt.Sprintf("%d", id))
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		Token: token,
		User: &model.User{
			ID:          fmt.Sprintf("%d", id),
			Email:       email,
			FirstName:   nullStringToPtr(firstName),
			LastName:    nullStringToPtr(lastName),
			PhoneNumber: nullStringToPtr(phoneNumber),
			Country:     nullStringToPtr(country),
			Job:         nullStringToPtr(job),
		},
	}, nil
}

// Signup is the resolver for the signup field.
func (r *mutationResolver) Signup(ctx context.Context, input model.SignupInput) (*model.AuthPayload, error) {
	if len(input.Password) < 6 {
		return nil, errors.New("password must be at least 6 characters")
	}

	// Check if email exists
	var exists bool
	err := DB.QueryRow("SELECT EXISTS(SELECT 1 FROM auth WHERE email=$1)", input.Email).Scan(&exists)
	if err != nil {
		return nil, err
	}
	if exists {
		return nil, errors.New("email already in use")
	}

	// Hash password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		return nil, err
	}

	// Insert into auth and return id
	var userID int64
	err = DB.QueryRow(
		"INSERT INTO auth (email, password) VALUES ($1, $2) RETURNING id",
		input.Email, hashedPassword,
	).Scan(&userID)
	if err != nil {
		return nil, err
	}

	// Insert into profile
	_, err = DB.Exec(`
		INSERT INTO user_profile (id, first_name, last_name, phone_number, country, job)
		VALUES ($1, $2, $3, $4, $5, $6)
	`, userID, input.FirstName, input.LastName, input.PhoneNumber, input.Country, input.Job)
	if err != nil {
		return nil, err
	}

	// Generate JWT
	token, err := utils.GenerateJWT(fmt.Sprintf("%d", userID))
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		Token: token,
		User: &model.User{
			ID:          fmt.Sprintf("%d", userID),
			Email:       input.Email,
			FirstName:   &input.FirstName,
			LastName:    &input.LastName,
			PhoneNumber: input.PhoneNumber,
			Country:     input.Country,
			Job:         input.Job,
		},
	}, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	userID, ok := GetUserIDFromContext(ctx)
	if !ok {
		return nil, errors.New("unauthenticated")
	}

	row := DB.QueryRow(`
		SELECT a.email, up.first_name, up.last_name, up.phone_number, up.country, up.job
		FROM auth a
		JOIN user_profile up ON a.id = up.id
		WHERE a.id = $1
	`, userID)

	var email string
	var firstName, lastName, phoneNumber, country, job sql.NullString

	err := row.Scan(&email, &firstName, &lastName, &phoneNumber, &country, &job)
	if err != nil {
		return nil, errors.New("user not found")
	}

	return &model.User{
		ID:          userID,
		Email:       email,
		FirstName:   nullStringToPtr(firstName),
		LastName:    nullStringToPtr(lastName),
		PhoneNumber: nullStringToPtr(phoneNumber),
		Country:     nullStringToPtr(country),
		Job:         nullStringToPtr(job),
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func nullStringToPtr(ns sql.NullString) *string {
	if ns.Valid {
		return &ns.String
	}
	return nil
}
*/
